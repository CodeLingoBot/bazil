// Code generated by protoc-gen-gogo.
// source: bazil.org/bazil/fs/snap/wire/snap.proto
// DO NOT EDIT!

/*
	Package wire is a generated protocol buffer package.

	It is generated from these files:
		bazil.org/bazil/fs/snap/wire/snap.proto

	It has these top-level messages:
		Dirent
		Type
		File
		Dir
		Snapshot
*/
package wire

import proto "github.com/gogo/protobuf/proto"
import math "math"

// discarding unused import gogoproto "github.com/gogo/protobuf/gogoproto/gogo.pb"
import bazil_cas "bazil.org/bazil/cas/wire"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = math.Inf

type Dirent struct {
	Name             string `protobuf:"bytes,1,req,name=name" json:"name"`
	Type             `protobuf:"bytes,2,req,name=type,embedded=type" json:"type"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Dirent) Reset()         { *m = Dirent{} }
func (m *Dirent) String() string { return proto.CompactTextString(m) }
func (*Dirent) ProtoMessage()    {}

func (m *Dirent) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// TODO is this any better than embedding these as optionals right
// into Dirent
type Type struct {
	File             *File  `protobuf:"bytes,1,opt,name=file" json:"file,omitempty"`
	Dir              *Dir   `protobuf:"bytes,2,opt,name=dir" json:"dir,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Type) Reset()         { *m = Type{} }
func (m *Type) String() string { return proto.CompactTextString(m) }
func (*Type) ProtoMessage()    {}

func (m *Type) GetFile() *File {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *Type) GetDir() *Dir {
	if m != nil {
		return m.Dir
	}
	return nil
}

type File struct {
	Manifest         bazil_cas.Manifest `protobuf:"bytes,1,req,name=manifest" json:"manifest"`
	XXX_unrecognized []byte             `json:"-"`
}

func (m *File) Reset()         { *m = File{} }
func (m *File) String() string { return proto.CompactTextString(m) }
func (*File) ProtoMessage()    {}

func (m *File) GetManifest() bazil_cas.Manifest {
	if m != nil {
		return m.Manifest
	}
	return bazil_cas.Manifest{}
}

type Dir struct {
	Manifest bazil_cas.Manifest `protobuf:"bytes,1,req,name=manifest" json:"manifest"`
	// If >0, the direntries are guaranteed to be aligned at
	// 1<<(12+align-1) byte boundaries (that is, minimum alignment is
	// 4kB).
	//
	// Required, with value 0 reserved for disabled, to avoid pointer
	// indirection costs for a few bytes.
	Align            uint32 `protobuf:"varint,2,req,name=align" json:"align"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Dir) Reset()         { *m = Dir{} }
func (m *Dir) String() string { return proto.CompactTextString(m) }
func (*Dir) ProtoMessage()    {}

func (m *Dir) GetManifest() bazil_cas.Manifest {
	if m != nil {
		return m.Manifest
	}
	return bazil_cas.Manifest{}
}

func (m *Dir) GetAlign() uint32 {
	if m != nil {
		return m.Align
	}
	return 0
}

// Snapshot as it is stored into CAS.
type Snapshot struct {
	Name             string `protobuf:"bytes,1,req,name=name" json:"name"`
	Contents         Dir    `protobuf:"bytes,2,req,name=contents" json:"contents"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Snapshot) Reset()         { *m = Snapshot{} }
func (m *Snapshot) String() string { return proto.CompactTextString(m) }
func (*Snapshot) ProtoMessage()    {}

func (m *Snapshot) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Snapshot) GetContents() Dir {
	if m != nil {
		return m.Contents
	}
	return Dir{}
}

func init() {
}
func (this *Type) GetValue() interface{} {
	if this.File != nil {
		return this.File
	}
	if this.Dir != nil {
		return this.Dir
	}
	return nil
}

func (this *Type) SetValue(value interface{}) bool {
	switch vt := value.(type) {
	case *File:
		this.File = vt
	case *Dir:
		this.Dir = vt
	default:
		return false
	}
	return true
}
